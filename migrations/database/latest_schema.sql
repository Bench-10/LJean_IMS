-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.add_stocks
(
    add_id serial NOT NULL,
    product_id integer NOT NULL,
    h_unit_price numeric(10, 2) NOT NULL,
    h_unit_cost numeric(10, 2) NOT NULL,
    quantity_added_display numeric(10, 3) NOT NULL,
    date_added date NOT NULL,
    product_validity date NOT NULL,
    quantity_left_display numeric(10, 3),
    branch_id integer,
    quantity_added_base bigint NOT NULL,
    quantity_left_base bigint NOT NULL,
    CONSTRAINT add_stocks_pkey PRIMARY KEY (add_id)
);

CREATE TABLE IF NOT EXISTS public.admin_notification
(
    admin_id integer NOT NULL,
    alert_id integer NOT NULL,
    is_read boolean DEFAULT true,
    CONSTRAINT admin_notification_pkey PRIMARY KEY (admin_id, alert_id)
);

CREATE TABLE IF NOT EXISTS public.administrator
(
    admin_id integer NOT NULL,
    role text[] COLLATE pg_catalog."default",
    username character varying(225) COLLATE pg_catalog."default",
    password character varying(225) COLLATE pg_catalog."default",
    first_name character varying(100) COLLATE pg_catalog."default",
    last_name character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT administrator_pkey PRIMARY KEY (admin_id)
);

CREATE TABLE IF NOT EXISTS public.branch
(
    branch_id integer NOT NULL,
    branch_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    address character varying(255) COLLATE pg_catalog."default" NOT NULL,
    cellphone_num character varying(20) COLLATE pg_catalog."default",
    telephone_num character varying(20) COLLATE pg_catalog."default",
    branch_email character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT branch_pkey PRIMARY KEY (branch_id)
);

CREATE TABLE IF NOT EXISTS public.category
(
    category_id serial NOT NULL,
    category_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT category_pkey PRIMARY KEY (category_id)
);

CREATE TABLE IF NOT EXISTS public.delivery
(
    delivery_id integer,
    sales_information_id integer,
    branch_id integer,
    destination_address character varying(255) COLLATE pg_catalog."default",
    delivered_date date,
    courier_name character varying(255) COLLATE pg_catalog."default",
    is_delivered boolean,
    is_pending boolean
);

CREATE TABLE IF NOT EXISTS public.inventory_alert_history_links
(
    alert_id integer NOT NULL,
    add_id integer NOT NULL,
    alert_timestamp timestamp with time zone DEFAULT now(),
    history_timestamp timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT inventory_alert_history_links_pkey PRIMARY KEY (alert_id),
    CONSTRAINT inventory_alert_history_links_add_id_key UNIQUE (add_id)
);

CREATE TABLE IF NOT EXISTS public.inventory_alert_sale_links
(
    alert_id integer NOT NULL,
    sales_information_id integer,
    delivery_id integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT inventory_alert_sale_links_pkey PRIMARY KEY (alert_id)
);

CREATE TABLE IF NOT EXISTS public.inventory_alerts
(
    alert_id serial NOT NULL,
    product_id integer,
    branch_id integer,
    alert_type character varying(100) COLLATE pg_catalog."default",
    message character varying(255) COLLATE pg_catalog."default",
    banner_color character varying(25) COLLATE pg_catalog."default",
    alert_date timestamp without time zone DEFAULT now(),
    user_id integer,
    user_full_name character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT inventory_alerts_pkey PRIMARY KEY (alert_id)
);

CREATE TABLE IF NOT EXISTS public.inventory_pending_actions
(
    pending_id serial NOT NULL,
    branch_id integer NOT NULL,
    product_id integer,
    action_type text COLLATE pg_catalog."default" NOT NULL,
    payload jsonb NOT NULL,
    status text COLLATE pg_catalog."default" NOT NULL DEFAULT 'pending'::text,
    created_by integer,
    created_by_name text COLLATE pg_catalog."default",
    created_by_roles text[] COLLATE pg_catalog."default",
    approved_by integer,
    approved_at timestamp without time zone,
    rejection_reason text COLLATE pg_catalog."default",
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    current_stage text COLLATE pg_catalog."default" NOT NULL DEFAULT 'manager_review'::text,
    requires_admin_review boolean NOT NULL DEFAULT false,
    manager_approver_id integer,
    manager_approved_at timestamp without time zone,
    admin_approver_id integer,
    admin_approved_at timestamp without time zone,
    cancelled_by integer,
    cancelled_at timestamp without time zone,
    cancelled_reason text COLLATE pg_catalog."default",
    revision_requested_by integer,
    revision_requested_at timestamp without time zone,
    revision_comments text COLLATE pg_catalog."default",
    revision_type text COLLATE pg_catalog."default",
    change_requested boolean DEFAULT false,
    change_request_type text COLLATE pg_catalog."default",
    change_request_comment text COLLATE pg_catalog."default",
    change_requested_by integer,
    change_requested_at timestamp without time zone,
    CONSTRAINT inventory_pending_actions_pkey PRIMARY KEY (pending_id)
);

CREATE TABLE IF NOT EXISTS public.inventory_product
(
    product_id integer NOT NULL,
    category_id integer NOT NULL,
    branch_id integer NOT NULL,
    product_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    unit character varying(15) COLLATE pg_catalog."default" NOT NULL,
    unit_price numeric(10, 2) NOT NULL,
    unit_cost numeric(10, 2) NOT NULL,
    quantity integer,
    min_threshold integer NOT NULL,
    low_stock_notified boolean DEFAULT false,
    max_threshold integer,
    base_unit character varying(15) COLLATE pg_catalog."default" NOT NULL,
    conversion_factor integer NOT NULL DEFAULT 1,
    CONSTRAINT inventory_product_pkey PRIMARY KEY (product_id, branch_id)
);

CREATE TABLE IF NOT EXISTS public.inventory_request_history
(
    history_id serial NOT NULL,
    pending_id integer NOT NULL,
    action_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    action_description text COLLATE pg_catalog."default" NOT NULL,
    user_name character varying(255) COLLATE pg_catalog."default",
    user_role character varying(100) COLLATE pg_catalog."default",
    action_date timestamp with time zone DEFAULT now(),
    old_payload jsonb,
    new_payload jsonb,
    additional_data jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT inventory_request_history_pkey PRIMARY KEY (history_id)
);

COMMENT ON TABLE public.inventory_request_history
    IS 'Tracks all changes and actions performed on inventory pending requests';

COMMENT ON COLUMN public.inventory_request_history.user_name
    IS 'User name stored as text to avoid foreign key constraints';

COMMENT ON COLUMN public.inventory_request_history.user_role
    IS 'User role stored as text for historical reference';

CREATE TABLE IF NOT EXISTS public.login_credentials
(
    user_id integer,
    username character varying(255) COLLATE pg_catalog."default" NOT NULL,
    password character varying(255) COLLATE pg_catalog."default" NOT NULL
);

CREATE TABLE IF NOT EXISTS public.password_reset_tokens
(
    id serial NOT NULL,
    user_id integer,
    admin_id integer,
    user_type character varying(10) COLLATE pg_catalog."default" NOT NULL,
    token character varying(64) COLLATE pg_catalog."default" NOT NULL,
    email character varying(255) COLLATE pg_catalog."default" NOT NULL,
    expires_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    used boolean DEFAULT false,
    used_at timestamp without time zone,
    CONSTRAINT password_reset_tokens_pkey PRIMARY KEY (id),
    CONSTRAINT password_reset_tokens_token_key UNIQUE (token),
    CONSTRAINT password_reset_tokens_user_id_admin_id_user_type_key UNIQUE (user_id, admin_id, user_type)
);

CREATE TABLE IF NOT EXISTS public.products
(
    product_id integer NOT NULL,
    product_name character varying(100) COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default" DEFAULT 'N/A'::text,
    CONSTRAINT products_pkey PRIMARY KEY (product_id)
);

CREATE TABLE IF NOT EXISTS public.push_subscriptions
(
    subscription_id serial NOT NULL,
    user_id integer,
    admin_id integer,
    user_type character varying(10) COLLATE pg_catalog."default" NOT NULL,
    endpoint text COLLATE pg_catalog."default" NOT NULL,
    p256dh_key text COLLATE pg_catalog."default" NOT NULL,
    auth_key text COLLATE pg_catalog."default" NOT NULL,
    user_agent text COLLATE pg_catalog."default",
    device_name character varying(255) COLLATE pg_catalog."default",
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    last_used timestamp without time zone DEFAULT now(),
    CONSTRAINT push_subscriptions_pkey PRIMARY KEY (subscription_id),
    CONSTRAINT push_subscriptions_endpoint_key UNIQUE (endpoint)
);

CREATE TABLE IF NOT EXISTS public.sales_information
(
    sales_information_id integer NOT NULL,
    branch_id integer,
    charge_to character varying(255) COLLATE pg_catalog."default",
    tin character varying(50) COLLATE pg_catalog."default",
    address character varying(255) COLLATE pg_catalog."default",
    date date,
    vat numeric(10, 2),
    amount_net_vat numeric(10, 2),
    total_amount_due numeric(10, 2),
    discount numeric(10, 2),
    transaction_by character varying(100) COLLATE pg_catalog."default",
    delivery_fee integer,
    is_for_delivery boolean DEFAULT false,
    CONSTRAINT sales_information_pkey PRIMARY KEY (sales_information_id)
);

CREATE TABLE IF NOT EXISTS public.sales_items
(
    product_item_id serial NOT NULL,
    sales_information_id integer,
    product_id integer,
    quantity_display numeric(10, 3),
    unit character varying(50) COLLATE pg_catalog."default",
    unit_price numeric(10, 2),
    amount numeric(10, 2),
    branch_id integer NOT NULL,
    quantity_base bigint NOT NULL,
    conversion_factor integer NOT NULL,
    CONSTRAINT sales_items_pkey PRIMARY KEY (product_item_id)
);

CREATE TABLE IF NOT EXISTS public.sales_stock_usage
(
    usage_id serial NOT NULL,
    sales_information_id integer NOT NULL,
    product_id integer NOT NULL,
    add_stock_id integer NOT NULL,
    quantity_used_display numeric(10, 3) NOT NULL,
    date_used timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    is_restored boolean DEFAULT false,
    restored_date timestamp without time zone,
    branch_id integer NOT NULL,
    quantity_used_base bigint NOT NULL,
    CONSTRAINT sales_stock_usage_pkey PRIMARY KEY (usage_id)
);

COMMENT ON TABLE public.sales_stock_usage
    IS 'Tracks which stock batches were used for each sale item, enabling precise stock restoration';

COMMENT ON COLUMN public.sales_stock_usage.is_restored
    IS 'TRUE when stock has been restored due to order cancellation/undelivered status';

CREATE TABLE IF NOT EXISTS public.unit_conversion
(
    unit_id serial NOT NULL,
    display_unit character varying(15) COLLATE pg_catalog."default" NOT NULL,
    base_unit character varying(15) COLLATE pg_catalog."default" NOT NULL,
    conversion_factor integer NOT NULL,
    unit_type character varying(20) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT unit_conversion_pkey PRIMARY KEY (unit_id),
    CONSTRAINT unit_conversion_display_unit_key UNIQUE (display_unit)
);

CREATE TABLE IF NOT EXISTS public.user_creation_requests
(
    request_id serial NOT NULL,
    pending_user_id integer,
    creator_user_id integer,
    creator_name text COLLATE pg_catalog."default",
    creator_roles text[] COLLATE pg_catalog."default",
    resolution_status text COLLATE pg_catalog."default" NOT NULL DEFAULT 'pending'::text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    resolved_at timestamp with time zone,
    manager_approver_id integer,
    manager_approved_at timestamp without time zone,
    owner_resolved_by integer,
    resolution_reason text COLLATE pg_catalog."default",
    deleted_at timestamp without time zone,
    deleted_by_user_id integer,
    deleted_by_admin_id integer,
    target_branch_id integer,
    target_branch_name text COLLATE pg_catalog."default",
    target_roles text[] COLLATE pg_catalog."default",
    target_full_name text COLLATE pg_catalog."default",
    target_username text COLLATE pg_catalog."default",
    target_cell_number text COLLATE pg_catalog."default",
    CONSTRAINT user_creation_requests_pkey PRIMARY KEY (request_id)
);

COMMENT ON COLUMN public.user_creation_requests.resolution_status
    IS 'Request status: pending (awaiting admin approval), approved (admin approved), rejected (admin rejected, user deleted), deleted (approved user later deleted)';

CREATE TABLE IF NOT EXISTS public.user_notification
(
    user_id integer NOT NULL,
    alert_id integer NOT NULL,
    is_read boolean DEFAULT true,
    CONSTRAINT user_notification_pkey PRIMARY KEY (user_id, alert_id)
);

CREATE TABLE IF NOT EXISTS public.users
(
    user_id integer NOT NULL,
    branch_id integer NOT NULL,
    role text[] COLLATE pg_catalog."default" NOT NULL,
    first_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    cell_number character varying(255) COLLATE pg_catalog."default" NOT NULL,
    is_active boolean,
    hire_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    last_login character varying(40) COLLATE pg_catalog."default",
    permissions text[] COLLATE pg_catalog."default",
    address character varying(255) COLLATE pg_catalog."default",
    is_disabled boolean,
    status character varying(20) COLLATE pg_catalog."default" DEFAULT 'active'::character varying,
    created_by character varying(255) COLLATE pg_catalog."default",
    approved_by character varying(255) COLLATE pg_catalog."default",
    approved_at timestamp without time zone,
    rejection_reason text COLLATE pg_catalog."default",
    created_by_user_id integer,
    CONSTRAINT users_pkey PRIMARY KEY (user_id)
);

ALTER TABLE IF EXISTS public.add_stocks
    ADD CONSTRAINT add_stocks_product_branch_fk FOREIGN KEY (product_id, branch_id)
    REFERENCES public.inventory_product (product_id, branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.admin_notification
    ADD CONSTRAINT admin_notification_admin_id_fkey FOREIGN KEY (admin_id)
    REFERENCES public.administrator (admin_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.admin_notification
    ADD CONSTRAINT admin_notification_alert_id_fkey FOREIGN KEY (alert_id)
    REFERENCES public.inventory_alerts (alert_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.delivery
    ADD CONSTRAINT delivery_sales_information_id_fkey FOREIGN KEY (sales_information_id)
    REFERENCES public.sales_information (sales_information_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_alert_history_links
    ADD CONSTRAINT inventory_alert_history_links_add_id_fkey FOREIGN KEY (add_id)
    REFERENCES public.add_stocks (add_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS inventory_alert_history_links_add_id_key
    ON public.inventory_alert_history_links(add_id);


ALTER TABLE IF EXISTS public.inventory_alert_history_links
    ADD CONSTRAINT inventory_alert_history_links_alert_id_fkey FOREIGN KEY (alert_id)
    REFERENCES public.inventory_alerts (alert_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS inventory_alert_history_links_pkey
    ON public.inventory_alert_history_links(alert_id);


ALTER TABLE IF EXISTS public.inventory_alert_sale_links
    ADD CONSTRAINT inventory_alert_sale_links_alert_id_fkey FOREIGN KEY (alert_id)
    REFERENCES public.inventory_alerts (alert_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS inventory_alert_sale_links_pkey
    ON public.inventory_alert_sale_links(alert_id);


ALTER TABLE IF EXISTS public.inventory_alerts
    ADD CONSTRAINT inv_alerts_product_branch_fk FOREIGN KEY (product_id, branch_id)
    REFERENCES public.inventory_product (product_id, branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_alerts
    ADD CONSTRAINT inventory_alerts_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branch (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_pending_actions
    ADD CONSTRAINT fk_inventory_pending_actions_revision_requested_by FOREIGN KEY (revision_requested_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.inventory_pending_actions
    ADD CONSTRAINT inventory_pending_actions_admin_approver_id_fkey FOREIGN KEY (admin_approver_id)
    REFERENCES public.administrator (admin_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_pending_actions
    ADD CONSTRAINT inventory_pending_actions_approved_by_fkey FOREIGN KEY (approved_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.inventory_pending_actions
    ADD CONSTRAINT inventory_pending_actions_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branch (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_pending_actions
    ADD CONSTRAINT inventory_pending_actions_cancelled_by_fkey FOREIGN KEY (cancelled_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.inventory_pending_actions
    ADD CONSTRAINT inventory_pending_actions_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.inventory_pending_actions
    ADD CONSTRAINT inventory_pending_actions_manager_approver_id_fkey FOREIGN KEY (manager_approver_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.inventory_product
    ADD CONSTRAINT inventory_product_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branch (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_product
    ADD CONSTRAINT inventory_product_category_id_fkey FOREIGN KEY (category_id)
    REFERENCES public.category (category_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_product
    ADD CONSTRAINT inventory_product_product_fk FOREIGN KEY (product_id)
    REFERENCES public.products (product_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.inventory_request_history
    ADD CONSTRAINT inventory_request_history_pending_id_fkey FOREIGN KEY (pending_id)
    REFERENCES public.inventory_pending_actions (pending_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_inventory_request_history_pending_id
    ON public.inventory_request_history(pending_id);


ALTER TABLE IF EXISTS public.login_credentials
    ADD CONSTRAINT login_credentials_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.password_reset_tokens
    ADD CONSTRAINT password_reset_tokens_admin_id_fkey FOREIGN KEY (admin_id)
    REFERENCES public.administrator (admin_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_admin
    ON public.password_reset_tokens(admin_id);


ALTER TABLE IF EXISTS public.password_reset_tokens
    ADD CONSTRAINT password_reset_tokens_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_user
    ON public.password_reset_tokens(user_id);


ALTER TABLE IF EXISTS public.push_subscriptions
    ADD CONSTRAINT push_subscriptions_admin_id_fkey FOREIGN KEY (admin_id)
    REFERENCES public.administrator (admin_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_admin
    ON public.push_subscriptions(admin_id);


ALTER TABLE IF EXISTS public.push_subscriptions
    ADD CONSTRAINT push_subscriptions_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user
    ON public.push_subscriptions(user_id);


ALTER TABLE IF EXISTS public.sales_information
    ADD CONSTRAINT sales_information_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branch (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.sales_items
    ADD CONSTRAINT sales_items_product_branch_fk FOREIGN KEY (product_id, branch_id)
    REFERENCES public.inventory_product (product_id, branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.sales_items
    ADD CONSTRAINT sales_items_sales_information_id_fkey FOREIGN KEY (sales_information_id)
    REFERENCES public.sales_information (sales_information_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.sales_stock_usage
    ADD CONSTRAINT sales_stock_product_branch_fk FOREIGN KEY (product_id, branch_id)
    REFERENCES public.inventory_product (product_id, branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.sales_stock_usage
    ADD CONSTRAINT sales_stock_usage_add_stock_id_fkey FOREIGN KEY (add_stock_id)
    REFERENCES public.add_stocks (add_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_sales_stock_usage_stock_id
    ON public.sales_stock_usage(add_stock_id);


ALTER TABLE IF EXISTS public.sales_stock_usage
    ADD CONSTRAINT sales_stock_usage_sales_information_id_fkey FOREIGN KEY (sales_information_id)
    REFERENCES public.sales_information (sales_information_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_sales_stock_usage_sale_id
    ON public.sales_stock_usage(sales_information_id);


ALTER TABLE IF EXISTS public.user_creation_requests
    ADD CONSTRAINT user_creation_requests_creator_user_id_fkey FOREIGN KEY (creator_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS user_creation_requests_creator_user_id_idx
    ON public.user_creation_requests(creator_user_id);


ALTER TABLE IF EXISTS public.user_creation_requests
    ADD CONSTRAINT user_creation_requests_deleted_by_admin_id_fkey FOREIGN KEY (deleted_by_admin_id)
    REFERENCES public.administrator (admin_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.user_creation_requests
    ADD CONSTRAINT user_creation_requests_deleted_by_user_id_fkey FOREIGN KEY (deleted_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.user_creation_requests
    ADD CONSTRAINT user_creation_requests_manager_approver_id_fkey FOREIGN KEY (manager_approver_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.user_creation_requests
    ADD CONSTRAINT user_creation_requests_owner_resolved_by_fkey FOREIGN KEY (owner_resolved_by)
    REFERENCES public.administrator (admin_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.user_creation_requests
    ADD CONSTRAINT user_creation_requests_pending_user_id_fkey FOREIGN KEY (pending_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS user_creation_requests_pending_user_id_idx
    ON public.user_creation_requests(pending_user_id);


ALTER TABLE IF EXISTS public.user_notification
    ADD CONSTRAINT user_notification_alert_id_fkey FOREIGN KEY (alert_id)
    REFERENCES public.inventory_alerts (alert_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.user_notification
    ADD CONSTRAINT user_notification_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.users
    ADD CONSTRAINT users_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branch (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.users
    ADD CONSTRAINT users_created_by_user_id_fkey FOREIGN KEY (created_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;

END;